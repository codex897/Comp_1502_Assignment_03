package mru.tsc.controller;

import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.ListView;
import javafx.scene.control.RadioButton;
import javafx.scene.control.TextField;
import javafx.scene.control.ToggleGroup;

import mru.tsc.model.Toy;
import mru.tsc.model.ToyStorageDB;

/**
 * Controller class for the Toy Store JavaFX GUI.
 * 
 * This class !!CURRENTLY!! handles all user interactions on the Home tab:
 *
 * @author Haseeb Ullah, Lorenzo ..., Alex ...
 * @version 1.0
 */
public class toyJavaFxController implements Initializable {
	
	//FXML HOME TAB CONTROLS

    @FXML private RadioButton rbSerial;
    @FXML private RadioButton rbName;
    @FXML private RadioButton rbType;

    @FXML private TextField txtSerialHome;
    @FXML private TextField txtNameHome;
    @FXML private TextField txtTypeHome;
    @FXML private Button btnSearchHome;
    @FXML private Button btnClearHome;
    @FXML private Button btnBuy;

    /** ListView used to display all toys or filtered search results. */
    @FXML private ListView<Toy> listViewHome;

                             //MODEL

    /**
     * Database object that manages all toy data, including
     * loading from and saving to the text file.
     */
    private ToyStorageDB toyDB;

    /**
     * Observable list backing the Home tab {@link ListView}.
     * It is repopulated when searching or after buying a toy.
     */
    private ObservableList<Toy> homeToyList;

    /**
     * Called automatically by the JavaFX framework after the FXML
     * file has been loaded. This method will:
     *
     *   Initializes the {@link ToyStorageDB}
     *   Loads toys from txt file
     *   Populates the Home tab {@link ListView}
     *   Sets up the {@link ToggleGroup} for the search radio buttons
     *
     * @param location  the location used to resolve relative paths, or {@code null}
     * @param resources the resources used to localize the root object, or {@code null}
     */
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        try {
            // Path to the toy data file (relative to the project root).
            String filePath = "res/toys.txt";

            // Create the database object and load all toys from the file.
            toyDB = new ToyStorageDB(filePath);
            toyDB.addData();   // Read and parse all lines from the file into the ArrayList

            // Get all toys from the database and wrap them in an ObservableList.
            ArrayList<Toy> allToys = toyDB.getToyDB();
            System.out.println("Loaded toys: " + allToys.size()); // Debug output in console
            homeToyList = FXCollections.observableArrayList(allToys);

            // Connect the observable list to the ListView on the Home tab.
            listViewHome.setItems(homeToyList);

            // Set up a ToggleGroup so only one search option can be selected at a time.
            ToggleGroup searchGroup = new ToggleGroup();
            rbSerial.setToggleGroup(searchGroup);
            rbName.setToggleGroup(searchGroup);
            rbType.setToggleGroup(searchGroup);

            // Default search mode is by serial number.
            rbSerial.setSelected(true);

        } catch (Exception e) {
            e.printStackTrace();
            showAlert(Alert.AlertType.ERROR,
                    "Initialization Error",
                    "Could not load toy data:\n" + e.getMessage());
        }
    }


    //HOME TAB: BUTTON HANDLERS
     
    /**
     * Handles the Search button on the Home tab.
     * 
     * This method checks which radio button is selected (serial number,
     * name, or the type) and filters the in-memory list of toys accordingly.
     * The filtered results are then displayed in {@link #listViewHome}.
     * If the required input field is empty, a warning alert is shown.
     * 
     *
     * @param event the {@link ActionEvent} generated by clicking the button
     */
    @FXML
    private void onSearchHome(ActionEvent event) {
        // Get a snapshot of all toys currently stored in the database.
        ArrayList<Toy> allToys = toyDB.getToyDB();
        List<Toy> results = new ArrayList<>();

        try {
            // --- Search by Serial Number ---
            if (rbSerial.isSelected()) {
                String sn = txtSerialHome.getText().trim();
                if (sn.isEmpty()) {
                    showAlert(Alert.AlertType.WARNING,
                            "Missing Input",
                            "Please enter a Serial Number.");
                    return;
                }

                // Exact match on serial number.
                for (Toy t : allToys) {
                    if (t.getSerialNum().equals(sn)) {
                        results.add(t);
                    }
                }

            // --- Search by Name ---
            } else if (rbName.isSelected()) {
                String name = txtNameHome.getText().trim();
                if (name.isEmpty()) {
                    showAlert(Alert.AlertType.WARNING,
                            "Missing Input",
                            "Please enter a Name.");
                    return;
                }

                String searchName = name.toLowerCase();

                // Case-insensitive, partial match on toy name.
                for (Toy t : allToys) {
                    if (t.getName().toLowerCase().contains(searchName)) {
                        results.add(t);
                    }
                }

            // --- Search by Type ---
            } else if (rbType.isSelected()) {
                String typeInput = txtTypeHome.getText().trim();
                if (typeInput.isEmpty()) {
                    showAlert(Alert.AlertType.WARNING,
                            "Missing Input",
                            "Please enter a Type (F/A/P/B or Figure/Animal/Puzzle/BoardGame).");
                    return;
                }

                // Normalize user input so that different formats map to the same toy type.
                String normalizedType = normalizeType(typeInput);

                // Match against each toy's typeOf() value.
                for (Toy t : allToys) {
                    if (t.typeOf().equalsIgnoreCase(normalizedType)) {
                        results.add(t);
                    }
                }
            }

            // If we did not find any toys, inform the user.
            if (results.isEmpty()) {
                showAlert(Alert.AlertType.INFORMATION,
                        "No Results",
                        "No toys matched your search.");
            }

            // Update the ListView with the filtered list (or empty list).
            homeToyList.setAll(results);

        } catch (Exception e) {
            e.printStackTrace();
            showAlert(Alert.AlertType.ERROR,
                    "Search Error",
                    "There was a problem searching the toys:\n" + e.getMessage());
        }
    }

    /**
     * Handles the Clear button on the Home tab.
     * 
     * This method clears all three search text fields and repopulates
     * the {@link ListView} with the full list of toys from the database.
     * 
     *
     * @param event the {@link ActionEvent} generated by clicking the button
     */
    @FXML
    private void onClearHome(ActionEvent event) {
        // Clear all user input fields on the Home tab.
        txtSerialHome.clear();
        txtNameHome.clear();
        txtTypeHome.clear();

        // Restore the full, unfiltered toy list.
        ArrayList<Toy> allToys = toyDB.getToyDB();
        homeToyList.setAll(allToys);
    }

    /**
     * Handles the Buy button on the Home tab.
     * 
     * This method:
     *
     *   Gets the selected toy from {@link #listViewHome}
     *   Decrements its stock count using {@link Toy#toyDecrement()}
     *   Removes the toy from the database if the count reach zero
     *   Saves all changes back to the toy data file
     *   Refreshes the ListView and shows a confirmation alert
     *   
     * If no toy is selected or the toy is out of stock, an appropriate
     * alert is displayed instead of changing the data.
     *
     * @param event the {@link ActionEvent} generated by clicking the button
     */
    @FXML
    private void onBuy(ActionEvent event) {
        // Get the toy the user selected in the ListView.
        Toy selected = listViewHome.getSelectionModel().getSelectedItem();

        // If nothing is selected, it cannot complete a purchase.
        if (selected == null) {
            showAlert(Alert.AlertType.WARNING,
                    "No Selection",
                    "Please select a toy from the list before clicking Buy.");
            return;
        }

        try {
            int currentCount = selected.getCount();

            // If the toy is already at zero stock, let the user know.
            if (currentCount <= 0) {
                showAlert(Alert.AlertType.INFORMATION,
                        "Out of Stock",
                        "This toy is already out of stock.");
                return;
            }

            // Decrement the stock by one using the helper in Toy.
            int newCount = selected.toyDecrement();

            // If the new count is zero, remove the toy from the database.
            if (newCount == 0) {
                toyDB.removeData(selected);
            }

            // Save the updated toy list back to the text file.
            toyDB.saveData();

            // Refresh the Home tab ListView with the updated toy list.
            ArrayList<Toy> allToys = toyDB.getToyDB();
            homeToyList.setAll(allToys);

            // Confirm the purchase to the user.
            showAlert(Alert.AlertType.INFORMATION,
                    "Purchase Successful",
                    "You bought:\n" + selected.toString());

        } catch (Exception e) {
            e.printStackTrace();
            showAlert(Alert.AlertType.ERROR,
                    "Purchase Error",
                    "Could not complete purchase:\n" + e.getMessage());
        }
    }

          //HELPER / UTILITY METHODS

    /**
     * Normalizes the user's type input into the exact string returned by
     * {@link Toy#typeOf()} so that searches are easier.
     * 
     * Supported inputs:
     * 
     *   Single letters: F, A, P, B (any case)
     *   Words: "figure", "animal", "puzzle", "board game",
     *       "boardgames", etc. (partial matches are allowed)
     *       
     *       
     * If the input does not match any known type, the original input is
     * returned so that an exact match might still work.
     *
     * @param input the raw string entered by the user
     * @return a normalized toy type string (e.g., "Figure", "Animal",
     *         "Puzzle", or "BoardGames"), or the original input if unknown
     */
    private String normalizeType(String input) {
        String t = input.trim().toLowerCase();

        // Case 1: single-character codes (F, A, P, B).
        if (t.length() == 1) {
            char c = Character.toUpperCase(t.charAt(0));
            switch (c) {
                case 'F': return "Figure";
                case 'A': return "Animal";
                case 'P': return "Puzzle";
                case 'B': return "BoardGames";
                default:  break; // Fall through to return original input
            }
        }

        // Case 2: longer words â€“ match by prefix.
        if (t.startsWith("fig"))   return "Figure";
        if (t.startsWith("ani"))   return "Animal";
        if (t.startsWith("puz"))   return "Puzzle";
        if (t.startsWith("board")) return "BoardGames";

        // Default: return the input unchanged (maybe already exactly "Figure", etc.).
        return input;
    }

    /**
     * Convenience method for showing alerts to the user.
     * 
     * The alert has no header text; it only displays a title and message
     * (content text). This method blocks until the user closes the dialog.
     *
     * @param type    the type of alert to show (e.g., {@link AlertType#ERROR})
     * @param title   the title displayed in the alert window
     * @param message the main message shown in the alert content area
     */
    private void showAlert(Alert.AlertType type, String title, String message) {
        Alert alert = new Alert(type);
        alert.setTitle(title);
        alert.setHeaderText(null); //No header,just the main message.
        alert.setContentText(message);
        alert.showAndWait();
    }
}
